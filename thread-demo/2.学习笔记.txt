1.当线程没有写主内存的操作时，java会优化成一直从高速缓存中取数。

2.高速缓存和主存之间的关系，可以类比于数据库和缓存的关系，都会遇到类似的问题。

3.
i=1;
i=i+1;
cpu1:main memory->cache(1)->cache(2)->main memory
cpu2:main memory->cache(1)->cache(2)->main memory

解决缓存一致性方案：
1.总线索 LOCK#  (地址总线，数据总线，控制总线)
2.缓存一致性协议 MESI
  1.当cpu写入数据时，发出一个信号，将持有该变量副本的缓存置为无效。
  2.当其他cpu来获取变量时，直接去主存中取。

并发编程三个重要概念：原子性A（要么都成功都失败），可见性V（一个线程的修改对另一个线程可见），
         顺序性O(代码按顺序执行，单例那块可能会先返回地址再初始化对象导致空指针)
         重排序针对没有依赖关系的，保证最终结果一致

JVM 规范，原子性：
1.基本数据类型的读取和赋值是原子性的。
a=10;原子
b=a; 不原子，1.read a 2.assign b;
2.可见性：volatile修饰的会执行缓存一致性协议
3.happens-before relationship
  1.一个线程内，编写在前面的发生在编写后面的。
  2.锁，unlock 必须发生在lock之后。
  3.volatile修饰的变量，对该变量的写操作，先于对该变量的读操作。
  4.传递性。
  5.线程启动规则：start肯定先于线程的run方法。
  6.线程的中断规则：interrupt 操作必须先于捕获异常之前。
  7.对象销毁规则：对象的初始化必须发生在finalize之前。
  8.线程终结规则：所有操作发生在线程死亡之前。

Volatile 操作：
1.volatile 修饰的语句加了屏障，屏障之前的操作会在屏障之前执行完成，屏障后面的会在屏障后面执行完成。
2.对缓存的修改，会被立即写入主存。
3.对变量的写操作，导致其他cpu的缓存失效。

使用场景：1.标记状态。2.保证屏障前后的一致性。
